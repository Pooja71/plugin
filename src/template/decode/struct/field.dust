/*
 * Javascript doesn't cover the set of primitives, so perform the
 * default value XOR at the bytes level for conceptual simplicity.  This
 * is blocked awaiting encoding facilities, e.g.
 * ```
 * // Within {~lb}@defaultByte type=x value=y position=z{~rb}:
 * var encode = require('encode/primitive');
 * // encode the default value's string and return the byte at `position`.
 * ```
 */
Object.defineProperty({target|s}.prototype, '{name}', {
    get : function () {
        /*
         * TODO: For all data section members use default values, e.g.
         * bytesOffset < {~lb}end{~rb} ? {~lb}this.__defAsdf[0]{~rb} ^ value[0] : {~lb}this.__def{~rb};
         */
        {?isDatum}
            {! Members of data section !}
            /* TODO: If the last bit of the sought datum runs off the end of the
             * data section, then provide the default value.  This probably
             * warrants some benchmarking.  Possible trick: impose on allocator
             * to put 0 into segments[0][0] so that default values have a
             * reliable zero to XOR against.  Under standard serialization,
             * these bytes are becomes unnecessary once cached.
             */
            {@select key=type}
            {@eq value="union"}
                return {>"primitive/UInt16" defaultValue="0" segment="this.__segment" begin="this.__dataSection" end="this.__pointerSection"/};
            {/eq}
            {@default}
                {?typeId}
                    {! Enum case !}
                    return {>"primitive/UInt16" defaultValue=defaultValue segment="this.__segment" begin="this.__dataSection" end="this.__pointerSection"/};
                {:else}
                    return {>"primitive/{type}" defaultValue=defaultValue segment="this.__segment" begin="this.__dataSection" end="this.__pointerSection"/};
                {/typeId}
            {/default}
            {/select}
        {:else}
            {#. segments="this.__segments"
                segment="this.__segment"
                begin="this.__pointerSection"}
                {@select key=type}
                {@eq value="group"} return new {target|s}.{name}(this); {/eq}
                {@eq value="List"} return {@listType elementType=elementType elementTypeId=elementTypeId depth=depth/}.deref({segments}, {segment}, {begin} + {@lsB word=offset/}, {depth}); {/eq}
                {@eq value="Text"} return Text.deref({segments}, {segment}, {begin} + {@lsB word=offset/}); {/eq}
                {@eq value="Data"} return Data.deref({segments}, {segment}, {begin} + {@lsB word=offset/}); {/eq}
                {@eq value="AnyPointer"} return AnyPointer.deref({segments}, {segment}, {begin} + {@lsB word=offset/}); {/eq}
                {@default} return exports['{typeId}'].deref({segments}, {segment}, {begin} + {@lsB word=offset/}); {/default}
                {/select}
            {/.}
        {/isDatum}
    },
    set : function () { throw new Error('Readonly'); }
});
