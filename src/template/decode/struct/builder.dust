var allocators = require('allocators');

exports.List = function List(allocator, parentSegment, bytes) {
    this.segment = allocator.allocate(bytes);
};

{#structs}
/**
 * @param {Allocator} allocator - Memory manager.
 * @param {Uint8Array} [parentSegment] - Segment of the {displayName}Builder's
 * parent.
 */

// AnyPointer use case: build with parentSegment === undefined and set the
// AnyPointer to the resultant.
// One and only one allocator may own

// slot.[struct display name for lookup purposes] 
  function {displayName}Builder(allocator, parentSegment) {
// TODO: struct/bytes returns (dataWordCount + pointerCount) * 8
    this.segment = allocator.allocate({@struct/bytes struct={.}}, parentSegment);
// TODO: generalize struct/bytes to list/bytes, etc.
// TODO: write zeros to data and pointer sections

    {#field.slot}
      {?type.isPointer}
        var rt = require('{type.builder.runtimeSource}');
// TODO: struct/pointerDatum returns 8*dataWordCount + datum
        Object.defineProperty(this, '{name}', {
          get : function () {
            if ({>pointer/isNull slot=slot segment='this.segment'}) {
// Struct case, this allocates the stack space for another object
// List case, this allocates the heap space
//  primitives case: encode list cardinality and byte size (allocator needs to know how many bytes to allocate too)
              {?type.list} var child = rt.{type.runtimeDS}(allocator, this.segment, {@listBytes}); {/type.list}
// List of what? Need to pass in constructors to parametrize the thing.
// List stride?

              var child = rt.{type.runtimeDS}(allocator, this.segment); // ok for builders, ng lists
                //List: rt.{type.runtimeDS}(allocator
              if (allocator.isFar(child.segment, this.segment)) {
// Don't implement hops here.
//   That arises under orphans I assume.
// Don't implement AnyPointers here.
//   Can't know what builder construct.
//   User must create the builder externally and directly attach it.
                var id = allocator.id(child.segment);
                return {>pointer/terminalFar target='child.segment' id='id'}; // byteOffset on target yields offset
              } else { //struct/terminalFar or list/terminalFar...?
                var 
              allocator.difference(child.segment, this.segment)
                return {>pointer/local source='this.segment' target='child.segment'};
              }
            }
          },
          set : function (value) {



          }
                
              

{@struct/pointerDatum words=dataWordCount datum='8'};
            return this._{name};
          },
          set : function (value) {
            this._{name} = {
       value;
        }

      {:else}
        {?slot.defaultValue}
          {>struct/writeDefault slot=slot segment='this.segment' datum='8'};
        {/slot.defaultValue}

        Object.defineProperty(this, '{name}', {
          get : function () { return {>struct/read slot=slot segment='this.segment' datum='8'}; },
          set : function (value) { {>struct/write slot=slot segment='this.segment' datum='8'}; }
        });
      {/type.runtimeDS}
    {/field.slot}
  };

  {?isRoot}
    exports.{displayName}Builder = {displayName}Builder;

    {displayName}Builder.psAllocation = function (pointerLength) {
      // @dataLengths populated by dataWordCount attribute of descendant structs
      var allocator = new allocators.PointerSection({@dataLengths root={.}}, pointerLength);

      return new {displayName}Builder(allocator);
    };
  {/isRoot}
{/structs]
