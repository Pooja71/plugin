/* Resolve requestedFiles to merge(x,y,z) for multifile generator requests. */
module.exports = {};

/*
 * Static methods resolve data and pointer sections from pointer input.
 * For a list with C=5, peek at the head of the field list to determine whether
 * `pointerSection` should be `begin` or `end`.
 */

{! List* !}
{@injectLists nodes=nodes/}

{! Text !}
{@injectBuiltType type="Text" nodes=nodes/}

{! Data !}
{@injectBuiltType type="Data" nodes=nodes/}

{! AnyPointer !}
{@injectBuiltType type="AnyPointer" nodes=nodes/}

{! Ignore non-structs (is struct iff there exists a fields key) !}
{#nodes}
{?fields}
    /* Struct {name} */
    exports['{id}'] = function (segments, segment, start, dataBytes, pointerBytes) {
        this.__segments = segments;
        this.__segment = segment;
        this.__dataSection = start;
        this.__pointerSection = start + dataBytes;
        this.__end = this.__pointerSection + pointerBytes;
    };

    /* Common base class for `instanceof` use. */
    exports['{id}'].prototype = new require('../base/struct')();

    /*
     * Map a `Struct` pointer to a {name} reader.
     * * For `AnyPointer` loci, inspection of the pointer's A bits can dispatch
     *   here as needed.
     * @param {Uint8Array[]} segments - All of the message segments.
     * @param {Uint8Array} segment - Segment of memory containing the pointer.
     * @param {Uint32} pointer - Byte offset into `segment` to where the pointer
     * starts.
     */
    exports['{id}'].deref = {>"far/deref" derefType="struct"/}
        {<derefBody}
            if (!{>"struct/is" segment="segment" pointer="pointer"/}) {
                throw new TypeError();
            }
        {/derefBody}
        {<derefReturns}
            new exports['{id}'](
                segments,
                targetSegment,
                start,
                {>"struct/dataBytes" segment="segment" pointer="pointer"/},
                {>"struct/pointerBytes" segment="segment" pointer="pointer"/})
        {/derefReturns}

    {#fields}
        /*
         * Javascript doesn't cover the set of primitives, so perform the
         * default value XOR at the bytes level for conceptual simplicity.  This
         * is blocked awaiting encoding facilities, e.g.
         * ```
         * var encode = require('encode/primitive');
         * var d{id}{name} = encode.Uint16({defaultValue});
         * // Anonymous union that exposes two different types with the same
         * // name => ? (name collisions on defaults?)
         * ```
         */
        Object.defineProperty(exports['{id}'].prototype, '{name}', {
            get : function () {
                /*
                 * TODO: for all primitive decodings, use default values, e.g.
                 * bytesOffset < {~lb}end{~rb} ? {~lb}defaultEncoding[0]{~rb} ^ value[0] : {~lb}defaultEncoding[0]{~rb};
                 */
                {?isDatum}
                    var d = d{id}{name};
                    return {>"primitive/{type}"
                                 defaultEncoding="d"
                                 segment="segment"
                                 begin="this.__dataSection"
                                 end="this.__pointerSection"/};
                {:else}
                    {#offset
                          segments="this.__segments"
                          segment="this.__segment"
                          begin="this.__pointerSection"}
                        {@select key=type}
                        /*
                         * Factory to map non-primitives:
                         *   NonprimitiveList(elementType)
                         *   \mapsto
                         *   {deref:function (segments, segment, pointer) {...}}
                         * (maintain {elementType : function (segments, segment,
                         *  pointer) {...}})
                         */
                        {@eq value="List"} return {@listType elementType=elementType/}.deref({segments}, {segment}, {begin} + {@lsB word="offset"/}); {/eq}
                        {@eq value="Text"} return Text.deref({segments}, {segment}, {begin} + {@lsB word="offset"/}); {/eq}
                        {@eq value="Data"} return Data.deref({segments}, {segment}, {begin} + {@lsB word="offset"/}); {/eq}
                        {@eq value="AnyPointer"} return AnyPointer.deref({segments}, {segment}, {begin} + {@lsB word="offset"/}); {/eq}
                        {@default} return exports['{typeId}'].deref({segments}, {segment}, {begin} + {@lsB word="offset"/}); {/default}
                        {/select}
                    {/offset}
                {/isDatum}
            },
            set : function () { throw new Error('Readonly'); }
        });
    {/fields}
{/fields}
{/nodes}

{#nodes}
{?fields}
    /*
     * Expose nested structs as static members on the owning struct.  Expose
     * root structs as exports.
     */
    {?owner}
        exports['{owner}'].{name} = exports['{id}'];
    {:else}
        exports.{name} = exports['{id}'];
    {/owner}
{/fields}
{/nodes}
