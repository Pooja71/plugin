{?type}
    var Base = require('../base/decode/List');

    var List = function (segments, segment, begin, length) {
        Base.call(this, segments, segment, begin, length);
    };

    List.prototype = Object.create(Base.prototype);

    List.prototype.get = function (index) {
        if (index<0 || this.__length<=index) {
            throw RangeError();
        }

        /*
         * This kinda sucks--someday there should be an iterator interface to
         * avoid the frequent `stride*i` computations.  The `byteOffset` helper
         * has some goofy logic going on too, but it's still semantic.
         */
        /*
         * Use index as a register to record the start of the struct's data
         * section.
         */
        index = this.__begin + {@byteOffset type=type offset="index"/};
        return {>"primitive/{type}" segment="segment" begin="index"/};
    };

    List.prototype.map = function (callback, context) {
        if (context) {
            callback = callback.bind(context);
        }

        var out = [];
        var i=this.length - 1;
        do {
            /* TODO: Optimize me */
            out[i] = callback(this.get(i));
        } while (--i)

        return out;
    };

    List.prototype.forEach = function (callback, context) {
        if (context) {
            callback = callback.bind(context);
        }

        for (var i=0; i<this.length; ++i) {
            /* TODO: Optimize me */
            callback(this.get(i), i, this);
        }
    };

    List.deref = {>"far/deref" derefType="list"/}
        {<derefReturns}
            new List(
                segments,
                targetSegment,
                start,
                {>"list/cardinality" segment="segment" pointer="pointer"/})
        {/derefReturns}

    module.exports = List;
{/type}
