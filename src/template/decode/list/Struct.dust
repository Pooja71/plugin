var Base = require('../../base/decode/List');

module.exports = function (Reader) {
    function List(segments, segment, begin, length, dataBytes, pointerBytes) {
        Base.call(this, segments, segment, begin, length);
        this.__dataBytes = dataBytes;
        this.__pointerBytes = pointerBytes;

        this.__stride = dataBytes + pointerBytes;
    }

    List.prototype = Object.create(Base.prototype);
    List.prototype.map = Base.prototype.map;
    List.prototype.forEach = Base.prototype.forEach;

    List.prototype.get = function (index) {
        if (index<0 || this.__length<=index) {
            throw new RangeError();
        }

        return new Reader(this.__segments,
                          this.__segment,
                          this.__begin + this.__stride*index,
                          this.__dataBytes,
                          this.__pointerBytes);
    };

    List.deref = {>"far/deref" derefType="list" nullValue="new List(null, null, null, 0, null, null)"/}
        {<derefBody}
            var dataBytes;
            switch ({>"list/sizeEnum" segment="segment" pointer="pointer"/}) {
            case {>"list/elementSize" enumerant="EMPTY"/}:
                dataBytes = 0; break;
            case {>"list/elementSize" enumerant="BYTE"/}:
                dataBytes = 1; break;
            case {>"list/elementSize" enumerant="TWO_BYTES"/}:
                dataBytes = 2; break;
            case {>"list/elementSize" enumerant="FOUR_BYTES"/}:
                dataBytes = 4; break;
            case {>"list/elementSize" enumerant="EIGHT_BYTES"/}:
                dataBytes = 8; break;
            case {>"list/elementSize" enumerant="INLINE_COMPOSITE"/}:
                dataBytes = {>"struct/dataBytes" segment="segment" pointer="pointer"/};
                return new List(
                    segments,
                    targetSegment,
                    start,
                    {>"struct/altCardinality" segment="targetSegment" start="start"/},
                    dataBytes,
                    {>"struct/pointerBytes" segment="segment" pointer="pointer"/});
            case elementSize.BIT:
                throw new Error('Bit alignment of packed lists is not supported');
            case elementSize.POINTER:
                throw new Error('Lists of pointers are specifically supported for each type, i.e. Nested, Text, and Data');
            default:
                throw new Error("Invalid message");
            }
        {/derefBody}
        {<derefReturns}
            new List(
                segments,
                targetSegment,
                start,
                {>"list/cardinality" segment="segment" pointer="pointer"/},
                dataBytes,
                0)
        {/derefReturns}

    return List;
};
