/* Base Class for instanceof-based resolution(?). */
var CodeRequest = function CodeRequest() {};

var structs = {};

/*
 * Static methods resolve data and pointer sections from pointer input.
 * For a list with C=5, peek at the head of the field list to determine whether
 * `pointerSection` should be `begin` or `end`.
 */

{#structs}
    /* Struct {name} */
    structs['{id}'] = function (segments, segment, dataSection, pointerSection, end) {
        this.id = '{id}';

        {#fields}
            Object.defineProperty(this, '{name}', {
                get : function () {
                    {?isDatum}
                        {>"primitive/{type}.dust" segment="segment" begin="dataSection"/}
                    {:else}
                        {@select key=type}
                        {@eq value="List"} return new rt.List(sig); {/eq}
                        {@eq value="Data"} return new rt.Data(sig); {/eq}
                        {@eq value="Text"} return new rt.Text(sig); {/eq}
                        {@eq value="AnyPointer"}
                            switch ({@pointer.type segment="segment" p="pointerSection"/}) {
                            case {@pointer.STRUCT /}:
                                return new AnyStruct(sig1);
                            case {@pointer.LIST /}:
                                return new AnyList(sig2);
                            /* Follow Far pointers and resolve to Struct or List. */
                            }
                            /*
                             * AnyPointer resolves to an interface for
                             * reinterpret casting (safety it up as much as
                             * possible)--AnyType()(?).
                             */
                        {/eq}
                        {@default} return new rt.{type}Reader(sig); {/default}
                        {/select}
                    {/isDatum}
                },
                set : function () { throw new Error('Readonly'); }
            });
        {/fields}
    };

    /*
     * Map a pointer to its object.  For `AnyPointer` loci, inspection of the
     * pointer's A bits can dispatch here as needed.  Finally, a `List` will
     * have to invoke the constructor directly, since `Struct` pointers in that
     * case take on a different interpretation.
     * @param {Uint8Array} segment - Segment of memory containing the pointer.
     * With type information available at compile time, this method can be
     * called blindly to generate a struct.
     * @param {Uint32} pointer - Byte offset into `segment` where the pointer
     * starts.
     */
    structs['{id}'].deref = function (segment, pointer) {};

    {?owner}
        structs['{owner}'].{name} = structs['{id}'];
    {:else}
        exports.{name} = structs['{id}'];
    {/owner}
{/structs}
