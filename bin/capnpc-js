#!/usr/bin/env node

var path = require('path');
var spawn = require('child_process').spawn;

var file = process.argv[process.argv.length-1];
var capnp = spawn('capnpc', ['-ocat', path.resolve(file)]);
var Buffers = require('buffers');

var n;
var buffers = new Buffers();
var sizes=[];
var start;
capnp.stdout.on('readable', function() {
    var chunk;
    var segment;
    while (null !== (chunk=capnp.stdout.read())) {
        if (n === undefined) {
            n = chunk.readUInt32LE(0) + 1;
            for (var i=0; i<n; ++i) {
                var size = 8*chunk.readUInt32LE(4*(i+1));
                sizes.push(size);
            }

            start = 4*n + (n%2 ? 4 : 8);
        }

        buffers.push(chunk);
    }
});

var segments = [];
capnp.stdout.on('end', function() {
    var CGR = require('../lib/cgr/readers');
    var context = require('../lib/context');
    for (var i=0; i<sizes.length; ++i) {
        segments.push(new Uint8Array(buffers.slice(start, start+sizes[i])));
        start += sizes[i];
    }

    if (start !== buffers.length) {
        throw new Error('All data has not been included');
    }

    var request = CGR.CodeGeneratorRequest.deref(segments, segments[0], 0);

    var files = request.getRequestedFiles();
    var nodes = request.getNodes();
    var trees = files.map(function (f) { return context(f, nodes); });

    var writer = function (x) {
        /* REPL writer that avoids long buffer echos. */
        if (x === undefined) { return; }

        if (x.toString !== undefined) {
            return x.toString();
        }

        return x;
    };

    /* Debugging environment */
    var repl = require('repl');
    var prompt = repl.start({ prompt : "> " });
    prompt.context.require = require;
    prompt.context.inspect = require('util').inspect;
    prompt.context.segments = segments;
    prompt.context.trees = trees;
    prompt.context.nodes = nodes;
});
