capnp-js [![Build Status](https://travis-ci.org/popham/capnp-js.svg?branch=master)](https://travis-ci.org/popham/capnp-js)
==========================================================================================================================

Yet another Capnproto implementation for Javascript.
[Dust](https://github.com/linkedin/dustjs) templates provide a literate codebase.
Most substance is currently under [decode](https://github.com/popham/capnp-js/tree/master/src/template/decode).

#CommonJS Modules
I'm building AMD modules--Nodefy will take care of building the CommonJS distribution.

#AMD Modules
The following strategy resolves circular references by populating prototypes as a final step: [filename+extension] ↦
* `[filename+extension].d/types.js`: Structure types, but without populated prototypes.
* `[filename+extension].d/scope.js`: Hash: (id ↦ Structure) to lookup any type that is available to the file's scope.
* `[filename+extension].d/constants.js`: Hash: (id ↦ Constant) to lookup constants that are local to the file's scope.
  These data could get included under `scope.js`, but would require that the current contents of `scope.js` were populated first.
  Similarly, these data could get included under `readers.js`, but `readers.js` would require that the contents of `constants.js` were populated first.
* `[filename+extension].d/readers.js`: Javascript implementation of `[filename+extension]`.
  This file exposes types by pet-name and populates prototypes.

AMD Use Case
------------
```
define(['rpc/peep'], function (Peep) {
    exports = {};

    exports.peep = function (meta) {
        var stream = fn(meta);
        return peep = new Peep(stream);
    };
});
```

Since full messages are required for reliable reading, the interface that `Peep` consumes can be relatively simple.
I like the prospect of exposing the RPC methods by [js-signals](http://millermedeiros.github.io/js-signals/).
API docs can get generated as markdown for rendering by whatever.


Javascript Array Buffers
------------------------
Capnproto has 64bit words and pointer offsets of 29bit plus a sign bit.
This yields 64*2^29 = 8*2^32 bits of memory.
Taking the 8*2^32 bits as the upper limit on the size of Capnproto messages, Javascript's `ArrayBuffer` indexed with 32bit unsigned integers covers the same address space.
I don't expect a browser to handle such messages, but it's theoretically capable.

Types
-----
64bit integral types require more space than Javascript can provide natively, so some alternative will be needed.
As of this writing, 64bit integers are returned as an array of two integers.
I considered providing the raw buffer, but endian interpretation tipped the balance toward the current strategy (DataView's performance [lags versus raw bitshiftery](http://jsperf.com/dataview-vs-typed-array-views)).


To do
-----
Constant values must be exposed to admit my testing strategy, so that's a priority.
I'd like to see testing sufficiently streamlined so that schema-specific tests can get generated by clients.
