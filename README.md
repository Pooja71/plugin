capnp-js [![Build Status](https://travis-ci.org/popham/capnp-js.svg?branch=master)](https://travis-ci.org/popham/capnp-js)
==========================================================================================================================

Yet another Capnproto implementation for Javascript.
[Dust](https://github.com/linkedin/dustjs) templates provide a literate codebase.
Most substance is currently under [decode](https://github.com/popham/capnp-js/tree/master/src/template/decode).

#CommonJS Modules
I want to support AMD by browserify, hence the use of browser types instead of node stuff.
I'm thinking to compartmentalize like so:
```
[filename].capnp ↦ [filename].js
struct [Name] {} ↦ exports.[Name] = function (segments, segment, bytes) {...};
struct [Name] { struct [Sub] {} } ↦ exports.[Name].[Sub] = ...;
```

AMD Use Case
------------
```
define(['rpc/peep'], function (Peep) {
    exports = {};

    exports.peep = function (meta) {
        var stream = fn(meta);
        return peep = new Peep(stream);
    };
});
```

Since full messages are required for reliable reading, the interface that `Peep` consumes can be relatively simple.
I like the prospect of exposing the RPC methods by [js-signals](http://millermedeiros.github.io/js-signals/).
API docs can get generated as markdown for rendering by whatever.


Javascript Array Buffers
------------------------
Capnproto has 64bit words and pointer offsets of 29bit plus a sign bit.
This yields 64*2^29 = 8*2^32 bits of memory.
Taking the 8*2^32 bits as the upper limit on the size of Capnproto messages, Javascript's `ArrayBuffer` indexed with 32bit unsigned integers covers the same address space.
I don't expect a browser to handle such messages, but it's theoretically capable.

Types
-----
64bit integral types require more space than Javascript can provide natively, so some alternative will be needed.
As of this writing, 64bit integers are returned as an array of two integers.
I considered providing the raw buffer, but endian interpretation tipped the balance toward the current strategy (DataView's performance [lags versus raw bitshiftery](http://jsperf.com/dataview-vs-typed-array-views)).


To do
-----
Constant values must be exposed to admit my testing strategy, so that's a priority.
I'd like to see testing sufficiently streamlined so that schema-specific tests can get generated by clients.
